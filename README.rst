=======
inextea
=======
The inextea library provides a small single block XTEA encryptor and
decryptor library with optional control of the number of Feistel rounds.
The library can be used to encrypt small (8-byte) payloads such as
customer IDs and similar.

Note that XTEA is not a particularly strong encryption algorithm due to
the small key length.  This library also does not support facilities, such as
cipher-block chaining, needed to properly encrypt larger payloads.  For this
reason, this library should not be used for general encryption applications.

The library includes two additional functions used to lightly encrypt customer
IDs and other 32-bit values into 8-byte sequences, including a simple
checksum.  These functions allow you to quickly encode integer values into
opaque sequences that are checksum'd and won't leak information such as the
number of subscribers.

The library was developed so that we could guarantee the use of the exact
same implementation of the xtea encryption algorithm with both C++ and
Python code.

Note that the `inecrypto <https://github.com/inesonic/inecrypto>` library
provides another implementation of the XTEA encryptor that can support
arbitrary block sizes.  The
`inecrypto <https://github.com/inesonic/inecrypto>` also includes a Qt
wrapper for the tiny-AES library with support for CBC.

The library was originally developed for the now defunct **SpeedSentry** site
monitoring system that was supported and sold by
`Inesonic, LLC <https://inesonic.com>`.


Python Extension Module
=======================
This small library includes a Python extension module you can use to perform
the XTEA encryption and decryption.  The Python extension module provides four
functions:


inextea.decrypt(block, key, number_rounds)
------------------------------------------
You can use this function to perform a specified number of reversed Feistel
rounds on a block.

+---------------+---------------------------------------------------------+
| Parameter     | Function                                                |
+===============+=========================================================+
| block         | The block to perform the Feistel rounds on.  Each block |
|               | must be exactly 8 bytes in length.                      |
+---------------+---------------------------------------------------------+
| key           | The Feistel key to be applied.  The key must be exactly |
|               | 16 bytes in length.                                     |
+---------------+---------------------------------------------------------+
| number_rounds | The number of Feistel rounds to be performed.           |
+---------------+---------------------------------------------------------+

The function returns a bytes object holding the decrypted block.


inextea.encrypt(block, key, number_rounds)
------------------------------------------
You can use this function to perform a specified number of Feistel rounds on a
block.

+---------------+---------------------------------------------------------+
| Parameter     | Function                                                |
+===============+=========================================================+
| block         | The block to perform the Feistel rounds on.  Each block |
|               | must be exactly 8 bytes in length.                      |
+---------------+---------------------------------------------------------+
| key           | The Feistel key to be applied.  The key must be exactly |
|               | 16 bytes in length.                                     |
+---------------+---------------------------------------------------------+
| number_rounds | The number of Feistel rounds to be performed.           |
+---------------+---------------------------------------------------------+

The function returns a bytes object holding the encrypted block.


inextea.to_customer_id(customer_identifier, key)
------------------------------------------------
You can use this function to convert a customer identifier generated by
``to_customer_identifier`` back to a 32-bit non-zero unsigned integer.

+---------------------+------------------------------------------------------+
| Parameter           | Description                                          |
+---------------------+------------------------------------------------------+
| customer_identifier | The 8-byte long customer identifier to be converted. |
+---------------------+------------------------------------------------------+
| key                 | The Feistel key to be applied.  The key must be      |
|                     | exactly 16 bytes in length.                          |
+---------------------+------------------------------------------------------+

The function returns a 32-bit integer customer ID value or 0 if the supplied
customer identifier is invalid.


inextea.to_customer_identifier(customer_id, key)
------------------------------------------------
You can use this function to convert a 32-bit integer customer ID to an 8-byte
customer identifier.

+-------------+------------------------------------------------------------+
| Parameter   | Description                                                |
+-------------+------------------------------------------------------------+
| customer_id | The integer customer ID to be converted to a customer      |
|             | identifier.                                                |
+-------------+------------------------------------------------------------+
| key         | The Feistel key to be applied.  The key must be exactly 16 |
|             | bytes in length.                                           |
+-------------+------------------------------------------------------------+

The function returns a byte array holding the 8-byte long customer identifier.


Building inextea
================
The build environment currently supports both qmake and cmake build tools.  You
will need to install the Python 3 headers.


qmake
-----
To build inextea and the inextea Python extension library using qmake:

.. code-block:: bash

   cd inecontainer
   mkdir build
   cd build
   qmake ../inextea.pro
   make

If you wish to create a debug build, change the qmake line to:

.. code-block:: bash

   qmake ../inextea.pro CONFIG+=debug
   make

Note that the qmake build environment currently does not have an install target
defined.

You may need to modify inextea.pro to point to the correct location for the
Python headers and shared libraries.


cmake
-----
To build inextea using cmake:

.. code-block:: bash

   cd inextea
   mkdir build
   cmake -B. -H.. -DCMAKE_INSTALL_PREFIX=/usr/local/
   make

The cmake build environment will install the inextea static library but will
not install the inextea Python extension library.  You will need to install
that library into an appropriate location manually.


Licensing
=========
This library is released under the MIT license.
